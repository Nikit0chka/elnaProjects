#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <beremiz/beremiz.h>

#include "POUS.h"
#include "iec_types_all.h"
#include "config1.h"
// clang-format off

#if (ELPLC_RUNTIME_VERSION_MAJOR != 3 || ELPLC_RUNTIME_VERSION_MINOR != 4)
#pragma message "Incompatible library version. Plugin=elplc_runtime Library=elplc_runtime Found=" STR(ELPLC_RUNTIME_VERSION_MAJOR) "." STR(ELPLC_RUNTIME_VERSION_MINOR) "." STR(ELPLC_RUNTIME_VERSION_PATCH)" Required=3.4.X."
#error "Incompatible library version"
#endif


#ifdef HAS_MP17
#include "beremiz-mp17.h"
#endif // HAS_MP17

//#include <eml.h>
#include <time.h>

#ifdef DEBUG_PLC
#define dbg(_PRNTMSG, ...) fprintf(stdout, "[PLC][dbg]:%20s:%d: " _PRNTMSG "\n", __func__, __LINE__, ##__VA_ARGS__)
#else
#define dbg(_PRNTMSG, ...) \
    do {                   \
    } while (0);
#endif // DEBUG_PLC

#ifdef DEBUG_PLC
#define err(_PRNTMSG, ...) fprintf(stderr, "[PLC][err][%s:%d]: " _PRNTMSG "\n", __func__, __LINE__, ##__VA_ARGS__)
#else
#define err(_PRNTMSG, ...) fprintf(stderr, "[PLC][err]: " _PRNTMSG "\n", ##__VA_ARGS__)
#endif // DEBUG_PLC

char CURRENT_DATE_TIME_STR[255];
static struct timespec t1, t2, t3, t4, t_prev, t_plug;
static IEC_ULINT t_retrieve_us, t_config_us, t_publish_us, t_current_run_us, t_retrieve_max_us = 0, t_config_max_us = 0, t_publish_max_us = 0;

pthread_mutex_t g__run_lock;

void config_run__(unsigned long tick);
void config_init__(void);

int stopPLC(void);

long long AtomicCompareExchange64(long long*, long long, long long);

/// Prototypes of functions exported by plugins
int __init_1(start_args_t *args);
void __cleanup_1(void);
void __retrieve_1(void);
void __publish_1(void);
int __init_0(start_args_t *args);
void __cleanup_0(void);
void __retrieve_0(void);
void __publish_0(void);

IEC_ULINT PLC_RUN_NUMBER = 0;

transfer_type_t g_transfer_type = OFFLINE;
brzrte_callbacks_t *g_callbacks = NULL;
tmpfs_stats_t *g_tmpfs_stats = NULL;

IEC_TIME __CURRENT_TIME;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpointer-sign"
IEC_ULINT *__IL0_10_10 = &__CURRENT_TIME.tv_sec;
IEC_ULINT *__IL0_10_11 = &__CURRENT_TIME.tv_nsec;
#pragma GCC diagnostic pop

IEC_BOOL __DEBUG = 0;

IEC_ULINT *__IL0_10_12 = &t_retrieve_us;
IEC_ULINT *__IL0_10_13 = &t_config_us;
IEC_ULINT *__IL0_10_14 = &t_publish_us;
IEC_ULINT *__IL0_10_15 = &t_current_run_us;
IEC_ULINT *__QL0_10_16 = &t_retrieve_max_us;
IEC_ULINT *__QL0_10_17 = &t_config_max_us;
IEC_ULINT *__QL0_10_18 = &t_publish_max_us;
IEC_ULINT *__IL0_10_19 = &PLC_RUN_NUMBER;

unsigned long __tick = 0;

#ifdef USE_ARCHIVER
int __archiver_init(start_args_t *args);
void __archiver_cleanup();
void __archiver_publish();
#endif

void __process_online_transfer();

int __variables_init(start_args_t *args);
int __retain_init(start_args_t *args);
void __variables_cleanup();
void __retain_publish();

extern unsigned long greatest_tick_count__;

/// Tick value in nanoseconds used by PLC clocking mechanism.
/// It would be multiple by value from resource file generated by elplc_compiler.
long long Ttick = 1000000;

/// Help to quit cleanly when init fail at a certain level
static int init_level = 0;

#ifdef USE_RDC
int __redundancy_init(start_args_t *args);
void __redundancy_sync();
void __redundancy_cleanup();
bool __redundancy_can_publish(int lvl);
bool __redundancy_can_retrieve(int lvl);
bool __redundancy_get_status();
#else
static bool __redundancy_can_publish(int lvl) {return true;};
static bool __redundancy_can_retrieve(int lvl) {return true;};
static bool __redundancy_get_status() {return true;}
#endif // USE_RDC

#ifdef USE_PlUGINS_TIME_PROFILER
#define PLUGIN_TIME_PROFILER(_PLUG_NAME_, _FUNC_CALL_) {                  \
        _FUNC_CALL_;                                                      \
        long last_time = t_plug.tv_sec * 1000000 + t_plug.tv_nsec / 1000; \
        clock_gettime(CLOCK_REALTIME, &t_plug);                           \
        long new_time = t_plug.tv_sec * 1000000 + t_plug.tv_nsec / 1000;  \
        printf("%-40s %luus\n", _PLUG_NAME_, new_time - last_time); }
#else
#define PLUGIN_TIME_PROFILER(_PLUG_NAME, _FUNC_CALL) \
    _FUNC_CALL
#endif // USE_PlUGINS_TIME_PROFILER


extern PROGRAM0 RESOURCE1__INSTANCE0;

void __run(void)
{
#ifdef GET_CURRENT_DATE_TIME_STR
  getTimeStr(CURRENT_DATE_TIME_STR);
#endif // GET_CURRENT_DATE_TIME_STR

  clock_gettime(CLOCK_REALTIME, &t_plug);
  __tick++;
  PLC_RUN_NUMBER++;
  if (greatest_tick_count__)
    __tick %= greatest_tick_count__;

  clock_gettime(CLOCK_REALTIME, &t1);

  pthread_mutex_lock(&g__run_lock);

  PLUGIN_TIME_PROFILER("retrieve_1         [elna]",                   if (__redundancy_can_retrieve(1)) __retrieve_1(););
  PLUGIN_TIME_PROFILER("retrieve_0         [OPC UA]",                 if (__redundancy_can_retrieve(2)) __retrieve_0(););

  //__retrieve_debug();

#ifdef USE_RDC
  PLUGIN_TIME_PROFILER("retrieve           [redundancy]",             __redundancy_sync());
#endif // USE_RDC

  clock_gettime(CLOCK_REALTIME, &t2);

  config_run__(__tick);

  clock_gettime(CLOCK_REALTIME, &t3);

  memcpy(&t_plug, &t3, sizeof(struct timespec));

  g_callbacks->publish_debug();

  PLUGIN_TIME_PROFILER("publish            [retain]",               __retain_publish());

  PLUGIN_TIME_PROFILER("publish_0          [OPC UA]",                 if (__redundancy_can_publish(2)) __publish_0(););
  PLUGIN_TIME_PROFILER("publish_1          [elna]",                   if (__redundancy_can_publish(1)) __publish_1(););

#ifdef USE_ARCHIVER
  PLUGIN_TIME_PROFILER("publish            [archiver]",               __archiver_publish());
#endif
  pthread_mutex_unlock(&g__run_lock);

  clock_gettime(CLOCK_REALTIME, &t4);
  t_current_run_us =    (t1.tv_sec - t_prev.tv_sec)*1000000 +
                        (t1.tv_nsec - t_prev.tv_nsec)/1000;
  t_retrieve_us =       (t2.tv_sec - t1.tv_sec)*1000000 +
                        (t2.tv_nsec - t1.tv_nsec)/1000;
  t_config_us =         (t3.tv_sec - t2.tv_sec)*1000000 +
                        (t3.tv_nsec - t2.tv_nsec)/1000;
  t_publish_us =        (t4.tv_sec - t3.tv_sec)*1000000 +
                        (t4.tv_nsec - t3.tv_nsec)/1000;
  if (t_retrieve_us > t_retrieve_max_us)
      t_retrieve_max_us = t_retrieve_us;
  if (t_config_us > t_config_max_us)
      t_config_max_us = t_config_us;
  if (t_publish_us > t_publish_max_us)
      t_publish_max_us = t_publish_us;
  memcpy(&t_prev, &t1, sizeof(struct timespec));

  g_tmpfs_stats->tick = PLC_RUN_NUMBER;

  time_profiler_t *t = &g_tmpfs_stats->time_profiler;
  t->tv_sec = t1.tv_sec;
  t->tv_nsec = t1.tv_nsec;
  t->current_run_us = t_current_run_us;
  t->retrieve_us = t_retrieve_us;
  t->retrieve_max_us = t_retrieve_max_us;
  t->config_us = t_config_us;
  t->publish_us = t_publish_us;
  t->publish_max_us = t_publish_max_us;

#ifdef USE_TIME_PROFILER
    {
      printf("%ld.%.9ld: t_run=%uus, t_ret=%u/%uus, t_conf=%uus, t_pub=%u/%uus\n",
         t1.tv_sec, t1.tv_nsec, t_current_run_us, t_retrieve_us, t_retrieve_max_us, t_config_us, t_publish_us, t_publish_max_us);
      LogMessage(LOG_DEBUG, "t_run=%uus, t_ret=%u/%uus, t_conf=%uus, t_pub=%u/%uus",
         t_current_run_us, t_retrieve_us, t_retrieve_max_us, t_config_us, t_publish_us, t_publish_max_us);
    }
#endif // USE_TIME_PROFILER

#ifdef USE_TIME_PROFILER_TIMEOUTS
    if ((t_current_run_us > (Ttick / 1000)) &&
      ((t_current_run_us - (Ttick / 1000)) > 1000 * 5)) {
      printf("LOOP OVERTIME: %ld.%.9ld: t_run=%lluus, t_ret=%llu/%lluus, t_conf=%lluus, t_pub=%llu/%lluus\n",
         t1.tv_sec, t1.tv_nsec, t_current_run_us, t_retrieve_us, t_retrieve_max_us, t_config_us, t_publish_us, t_publish_max_us);
      char m[LOG_SIZE];
      LogMessage(LOG_LOOP_OVERTIME, "current_cycle_time=%ld; project_cycle_time=%lld\0", t_current_run_us, Ttick / 1000);
    }
#endif // USE_TIME_PROFILER_TIMEOUTS

    if (g_transfer_type != OFFLINE){
        g_callbacks->online_transfer.setLastTime(&t1);
        g_callbacks->online_transfer.setRunNumber(PLC_RUN_NUMBER);
        dbg("Starting Online transfer");
        __process_online_transfer();
    }
}

int __init(start_args_t *args)
{
  int res = 0;
  init_level = 0;

  g_callbacks = args->callbacks;
  g_tmpfs_stats = args->tmpfs_stats;

  PLC_RUN_NUMBER = 0;

  // Effective tick time with 1ms default value
  if (common_ticktime__)
    Ttick = common_ticktime__;

  if (args->transfer_type == OFFLINE)
      config_init__();
  //__init_debug();

  clock_gettime(CLOCK_REALTIME, &t_plug);

  // when ONLINE transfer is executing, these methods are already run by OnlineTransferInitNewLibrary()
  if (args->transfer_type == OFFLINE) {
      PLUGIN_TIME_PROFILER("init               [variables]",             if((res = __variables_init(args))){return res;});

      PLUGIN_TIME_PROFILER("init               [retain]",                if((res = __retain_init(args))){return res;});

#ifdef USE_RDC
      PLUGIN_TIME_PROFILER("init               [redundancy]",             if((res = __redundancy_init(args))){return res;});
#endif // USE_RDC
  }

  PLUGIN_TIME_PROFILER("init_1             [elna]",                   init_level=1; if((res = __init_1(args))){return res;});
  PLUGIN_TIME_PROFILER("init_0             [OPC UA]",                 init_level=2; if((res = __init_0(args))){return res;});

#ifdef USE_ARCHIVER
  PLUGIN_TIME_PROFILER("init               [archiver]",             if((res = __archiver_init(args))){return res;});
#endif

  g_transfer_type = OFFLINE;

  clock_gettime(CLOCK_REALTIME, &t1);

  if ((pthread_mutex_init(&g__run_lock, NULL)) == -1) {
      err("Internal error: %s", strerror(errno));
      return -1;
  }

  if (args->transfer_type != OFFLINE){
    g_callbacks->online_transfer.getLastTime(&t_prev);
    PLC_RUN_NUMBER = g_callbacks->online_transfer.getRunNumber();

    int diff = (t1.tv_sec - t_prev.tv_sec)*1000000 + (t1.tv_nsec - t_prev.tv_nsec)/1000;
    dbg("Online transfer successfully executed [%d us]. Program thread started.", diff);
    LogMessage(LOG_INFO, "Online transfer successfully executed [%d us]. Program thread started.", diff);

    diff = (Ttick / 1000) - diff;

    if (diff > 0)
        usleep(diff);

  } else {
    memcpy(&t_prev, &t1, sizeof(struct timespec));
  }
  return res;
}

void __cleanup(void)
{
  clock_gettime(CLOCK_REALTIME, &t_plug);

  PLUGIN_TIME_PROFILER("cleanup_0          [OPC UA]",                 if(init_level >= 2) __cleanup_0(););
  PLUGIN_TIME_PROFILER("cleanup_1          [elna]",                   if(init_level >= 1) __cleanup_1(););
#ifdef USE_RDC
  PLUGIN_TIME_PROFILER("cleanup            [redundancy]",             __redundancy_cleanup());
#endif // USE_RDC

  //__cleanup_debug();
#ifdef USE_ARCHIVER
  PLUGIN_TIME_PROFILER("cleanup            [archiver]",               __archiver_cleanup());
#endif

  PLUGIN_TIME_PROFILER("cleanup            [variables]",             __variables_cleanup());
}

/// Arch-specific timer functions
void PLC_GetTime(IEC_TIME *CURRENT_TIME);
void PLC_SetTimer(unsigned long long next, unsigned long long period);
void setShedulerRT(void);
static bool g_shed_rt_enabled = false;

bool GetRedundancyStatus(){ return __redundancy_get_status(); }

/// @brief Priority for realtime scheduler
#define TASK_PRIORITY 99

pthread_t PLC_thread;

/// Global flag to stop PLC thread.
int PLC_shutdown = 0;

static pthread_mutex_t Run_PLC;

/// @defgroup Clocking mechanism definitions.
/// @{
static int clocking_init(void);
static void clocking_clean(void);
/// @}

void PLC_timer_notify(sigval_t val)
{
    PLC_GetTime(&__CURRENT_TIME);
    pthread_mutex_unlock(&Run_PLC);
}

/// Thread that runs PLC cycles.
void PLC_thread_proc(void *arg)
{
    (void)arg;

   if (g_shed_rt_enabled)
      setShedulerRT();

    while (!PLC_shutdown) {
        pthread_mutex_lock(&Run_PLC);
        __run();
    }

    pthread_exit(0);
}

int startPLC(start_args_t *args)
{
//    setlocale(LC_NUMERIC, "C");

    PLC_shutdown = 0;

    g_shed_rt_enabled = args->cfg->shed_rt == 0 ? false : true;

    // Prepare clocking mechanism
    if ((pthread_mutex_init(&Run_PLC, NULL)) == -1)
        return -1;
    pthread_mutex_lock(&Run_PLC);
    if ((clocking_init()) == -1) {
        perror("clocking_init");
        exit(EXIT_FAILURE);
    }

    if ((pthread_create(&PLC_thread, NULL, (void*)&PLC_thread_proc, NULL)) != 0) {
        perror("pthread_create");
        exit(EXIT_FAILURE);
    }

    // Initialize debug and configuration sections.
    if ((__init(args)) != 0) {
        // FIXME: Free resources on fail??
        return 1;
    }

    // Reset clocking tick interval and current value.
    PLC_SetTimer(Ttick, Ttick);

    if (args->transfer_type == OFFLINE)
        LogMessage(LOG_INFO, "PLC for target 'Linux' started successfully");

    return 0;
}

int stopPLC()
{
    /* Stop the PLC */
    PLC_shutdown = 1;
    pthread_mutex_unlock(&Run_PLC);
    PLC_SetTimer(0,0);
    pthread_join(PLC_thread, NULL);
    pthread_mutex_destroy(&Run_PLC);
    clocking_clean();
    __cleanup();

    if (g_transfer_type == OFFLINE)
        LogMessage(LOG_INFO, "PLC stopped successfully");

    return 0;
}

/// Sets CURRENT_TIME value that accessable to IDE user.
void PLC_GetTime(IEC_TIME *CURRENT_TIME)
{
    struct timespec tmp;
    clock_gettime(CLOCK_REALTIME, &tmp);
    CURRENT_TIME->tv_sec = tmp.tv_sec;
    CURRENT_TIME->tv_nsec = tmp.tv_nsec;
}

// clang-format on
/**
 * @file plc_Linux_main.c
 */
#include <fcntl.h>
#include <locale.h>
#include <pthread.h>
#include <sched.h>
#include <semaphore.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

/// @defgroup Clocking mechanism definitions.
/// @{
static int clocking_init(void);
static void clocking_clean(void);
/// @}

long AtomicCompareExchange(long* atomicvar,long compared, long exchange)
{
    return __sync_val_compare_and_swap(atomicvar, compared, exchange);
}
long long AtomicCompareExchange64(long long* atomicvar, long long compared, long long exchange)
{
    return __sync_val_compare_and_swap(atomicvar, compared, exchange);
}

/// POSIX timer used to clock PLC cycles.
static timer_t PLC_timer;

/// Arm POSIX timer that will clock PLC using separate thread.
static int clocking_init(void)
{
    struct sigevent sigev;

    memset(&sigev, 0, sizeof (struct sigevent));
    sigev.sigev_value.sival_int = 0;
    sigev.sigev_notify = SIGEV_THREAD;
    sigev.sigev_notify_attributes = NULL;
    sigev.sigev_notify_function = PLC_timer_notify;

    if ((timer_create(CLOCK_REALTIME, &sigev, &PLC_timer)) == -1)
        return -1;

    return 0;
}

/// Clean resources used by POSIX timer.
static void clocking_clean(void)
{
    PLC_SetTimer(0, 0);
    timer_delete(PLC_timer);
}

void PLC_SetTimer(unsigned long long next, unsigned long long period)
{
    struct itimerspec timerValues;
	/*
	printf("SetTimer(%lld,%lld)\n",next, period);
	*/
    memset (&timerValues, 0, sizeof (struct itimerspec));
	{
#ifdef __lldiv_t_defined
		lldiv_t nxt_div = lldiv(next, 1000000000);
		lldiv_t period_div = lldiv(period, 1000000000);
	    timerValues.it_value.tv_sec = nxt_div.quot;
	    timerValues.it_value.tv_nsec = nxt_div.rem;
	    timerValues.it_interval.tv_sec = period_div.quot;
	    timerValues.it_interval.tv_nsec = period_div.rem;
#else
	    timerValues.it_value.tv_sec = next / 1000000000;
	    timerValues.it_value.tv_nsec = next % 1000000000;
	    timerValues.it_interval.tv_sec = period / 1000000000;
	    timerValues.it_interval.tv_nsec = period % 1000000000;
#endif
	}
    timer_settime (PLC_timer, 0, &timerValues, NULL);
}
/** @file plc_main_tail.c */
int LogMessageImpl(uint8_t level, char *buf, uint32_t size){
  if (g_callbacks == NULL)
    return 0;
  return g_callbacks->log.LogMessageCB(level, PLC_RUN_NUMBER, buf, size);
}
void ResetLogCount(void){
  g_callbacks->log.ResetLogCount();
}

uint32_t GetLogCount(uint8_t level) {
  return g_callbacks->log.GetLogCount(level);
}

uint32_t GetLogMessage(uint8_t level, uint32_t msgidx, char *buf,
                       uint32_t max_size, uint32_t *tick, uint32_t *tv_sec, uint32_t *tv_nsec){
  return g_callbacks->log.GetLogMessage(level, msgidx, buf, max_size, tick, tv_sec, tv_nsec);
}

#define CALIBRATED -2
#define NOT_CALIBRATED -1
static int calibration_count = NOT_CALIBRATED;
static IEC_TIME cal_begin;
static long long Tsync = 0;
static long long FreqCorr = 0;
static int Nticks = 0;
static unsigned long last_tick = 0;

/**
 * @brief Calibrate ticks
 *
 * Called on each external periodic sync event
 * make PLC tick synchronous with external sync
 * ratio defines when PLC tick occurs between two external sync
 * @param sync_align_ratio
 *          0->100 : align ratio
 *          < 0 : no align, calibrate period
 */
void align_tick(int sync_align_ratio)
{
    /* Tick calibration */
	if(sync_align_ratio < 0){

		/* Re-calibration*/
		if(calibration_count == CALIBRATED) {
			calibration_count = NOT_CALIBRATED;
		}

	    /* Calibration start, get time*/
		if(calibration_count == NOT_CALIBRATED) {
			PLC_GetTime(&cal_begin);
		}
		calibration_count++;

	/* Do alignment (if it possible) */
	} else {
		if(calibration_count >= 0) {
			/* End of calibration */
			/* Get final time */
			IEC_TIME cal_end;
			PLC_GetTime(&cal_end);
			/* Adjust calibration_count*/
			calibration_count++;
			/* Compute mean of Tsync, over calibration period */
			Tsync = ((long long)(cal_end.tv_sec - cal_begin.tv_sec) * (long long)1000000000 +
					(cal_end.tv_nsec - cal_begin.tv_nsec)) / calibration_count;
			if( (Nticks = (Tsync / Ttick)) > 0) {
				FreqCorr = (Tsync % Ttick); /* to be divided by Nticks */
			} else {
				FreqCorr = Tsync - (Ttick % Tsync);
			}

			calibration_count = CALIBRATED;
		}

		if(calibration_count == CALIBRATED) {
			/* Get Elapsed time since last PLC tick (__CURRENT_TIME) */
			IEC_TIME now;
			long long elapsed;
			long long Tcorr;
			long long PhaseCorr;
			long long PeriodicTcorr;
			PLC_GetTime(&now);
			elapsed = (now.tv_sec - __CURRENT_TIME.tv_sec) * 1000000000 + now.tv_nsec - __CURRENT_TIME.tv_nsec;
			if(Nticks > 0) {
				PhaseCorr = elapsed - (Ttick + FreqCorr/Nticks)*sync_align_ratio/100; /* to be divided by Nticks */
				Tcorr = Ttick + (PhaseCorr + FreqCorr) / Nticks;
				if(Nticks < 2) {
					/* When Sync source period is near Tick time */
					/* PhaseCorr may not be applied to Periodic time given to timer */
					PeriodicTcorr = Ttick + FreqCorr / Nticks;
				} else {
					PeriodicTcorr = Tcorr;
				}
			} else if(__tick > last_tick) {
				last_tick = __tick;
				PhaseCorr = elapsed - (Tsync*sync_align_ratio/100);
				PeriodicTcorr = Tcorr = Ttick + PhaseCorr + FreqCorr;
			} else {
				/* PLC did not run meanwhile. Nothing to do */
				return;
			}
			/* DO ALIGNEMENT */
			PLC_SetTimer(Tcorr - elapsed, PeriodicTcorr);
		}
	}
}

#define GPIO_ROLE_PORT 9

#define FILEPATHLEN 512


/// @brief Export given GPIO port with 'in' direction and open it value fd
/// @return Opened fd if success, -1 and sets errno otherwise
static int gpio_open(int gpio_num)
{
    assert(gpio_num > 0);

    int fd;
    FILE *fexp, *fdir;
    char pathname[FILEPATHLEN];

    fexp = fopen("/sys/class/gpio/export", "w");
    if (fexp == NULL) {
        err("Error opening /sys/class/gpio/export");
        return -1;
    }

    fprintf(fexp, "%d", gpio_num);
    fclose(fexp);

    snprintf(pathname, sizeof(pathname), "/sys/class/gpio/gpio%d/direction", gpio_num);
    fdir = fopen(pathname, "w");
    if (fdir == NULL) {
        err("Error opening %s", pathname);
        return -1;
    }

    fprintf(fdir, "in\n");
    fclose(fdir);

    snprintf(pathname, sizeof(pathname), "/sys/class/gpio/gpio%d/value", gpio_num);
    fd = open(pathname, O_RDONLY);
    if (fd < 0) {
        err("Error opening %s", pathname);
        return -1;
    }

    return fd;
}

int read_role_from_gpio(gpio_role_t *role)
{
    int fd;
    char val[2] = {0};
    char *end;
    long val_buf;

    fd = gpio_open(GPIO_ROLE_PORT);
    if (fd == -1)
        return -1;

    if (read(fd, val, 1) == -1) {
        close(fd);
        return -1;
    }
    close(fd);
    val[1] = '\0';

    val_buf = strtol(val, &end, 10);
    if ((end == val) || (*end != '\0')) {
        err("gpio%d: Broken data", GPIO_ROLE_PORT);
        errno = EINVAL;
        return -1;
    } else if ((val_buf != GPIO_ROLE_PRIMARY) && (val_buf != GPIO_ROLE_STANDBY)) {
        err("%d: Broken value: %ld", GPIO_ROLE_PORT, val_buf);
        errno = EINVAL;
        return -1;
    }

    *role = (int)val_buf;
    dbg("Read processor role from GPIO: %s", *role == GPIO_ROLE_PRIMARY ? "primary" : "standby");
    LogMessage(LOG_DEBUG, "Read processor role from GPIO: %s", *role == GPIO_ROLE_PRIMARY ? "primary" : "standby");


    return 0;
}

void getTimeStr(char *res){
  time_t t = time(NULL);
  struct tm tm = *localtime(&t);
  sprintf(res, "%d-%02d-%02d %02d:%02d:%02d", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
}

void setShedulerRT(void)
{
    pthread_attr_t thread_attr;
    struct sched_param param;

    // Force realtime scheduling for this thread.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wimplicit-function-declaration"
    pthread_getattr_np(pthread_self(), &thread_attr);
#pragma GCC diagnostic pop
    pthread_attr_getschedparam(&thread_attr, &param);
    param.sched_priority = sched_get_priority_max(SCHED_FIFO);
    if ((pthread_setschedparam(pthread_self(), SCHED_FIFO, &param)) < 0) {
      perror("sched_setscheduler");
      exit(EXIT_FAILURE);
    }
}

int64_t GetCurrentTick(){ return PLC_RUN_NUMBER; }

bool EnterCriticalSection(int sec)
{
    int msec;
    for(msec = 0; msec < sec * 1000; msec +=10) {
      if (pthread_mutex_trylock(&g__run_lock))
        return true;
    }

    return false;
}

bool LeaveCriticalSection()
{
    pthread_mutex_unlock(&g__run_lock);
    return true;
}

// clang-format on
